{
  "step_id": "arch_design",
  "role": "Architect",
  "timestamp": "2026-02-07T20:24:46.932Z",
  "content": {
    "design_doc": "## System Architecture Overview\n\nThe Restaurant Management Platform is designed as a cloud-native, event-driven system to ensure sub-second synchronization between Point of Sale (POS) terminals and Kitchen Display Systems (KDS). The architecture prioritizes high availability, offline tolerance, and data consistency.\n\n### Core Components\n\n1.  **Client Layer**: \n    - **POS Tablet App**: A React Native application optimized for 10-inch tablets. It utilizes a local SQLite database (WatermelonDB) to store menu data and active orders, enabling full offline functionality. Synchronization occurs via a background sync engine when connectivity is restored.\n    - **KDS Web App**: A React-based Single Page Application (SPA) running on kitchen hardware. It relies on persistent WebSocket connections to receive real-time order tickets.\n    - **Manager Portal**: A web dashboard for menu configuration, floor plan editing, and analytics.\n\n2.  **API Gateway & Load Balancer**: \n    - Nginx acts as the entry point, handling SSL termination, rate limiting, and routing traffic to the backend services.\n\n3.  **Backend Services (Modular Monolith)**:\n    - Built with Node.js (NestJS), the backend is structured into domain modules (Orders, Inventory, Staff, Payments). \n    - **Real-time Engine**: A dedicated WebSocket service (Socket.io adapter backed by Redis) handles the broadcasting of events (e.g., `ORDER_CREATED`, `ITEM_BUMPED`) to connected KDS clients.\n\n4.  **Data Layer**:\n    - **Primary Database**: PostgreSQL serves as the source of truth for all transactional data. It uses a multi-tenant schema design (row-level security via `restaurant_id`).\n    - **Cache**: Redis is used for session management and caching frequently accessed menu data to reduce database load.\n\n### Data Flow\n\n1.  **Order Creation**: Server inputs order on POS -> Local DB save -> API POST (background sync) -> Backend validates -> DB Insert -> Event Published to Redis.\n2.  **Kitchen Notification**: Redis Subscriber -> WebSocket Service -> Broadcast to specific Restaurant Room -> KDS renders ticket.\n3.  **Completion**: Cook bumps order on KDS -> API PATCH -> DB Update -> WebSocket notifies POS (server alerted).\n\n### Offline Strategy\n\nTo satisfy the critical requirement of continuous operation, the POS generates UUIDv7 primary keys locally. This allows complex relational data (Orders -> OrderItems -> Modifiers) to be created without waiting for a server response. Conflict resolution uses a 'last-write-wins' strategy for status updates, while append-only logs are used for financial transactions.",
    "apis": [
      {
        "path": "/api/v1/orders",
        "method": "POST",
        "description": "Submit a new order from POS.",
        "request_schema": {
          "tableId": "string",
          "items": "array",
          "serverNotes": "string"
        },
        "response_schema": {
          "id": "string",
          "status": "string",
          "createdAt": "string"
        },
        "auth_required": true,
        "rate_limit": "60 req/min"
      },
      {
        "path": "/api/v1/orders",
        "method": "GET",
        "description": "Retrieve active orders for KDS.",
        "request_schema": {
          "status": "string",
          "limit": "number",
          "cursor": "string"
        },
        "response_schema": {
          "data": "array",
          "nextCursor": "string"
        },
        "auth_required": true,
        "rate_limit": "100 req/min"
      },
      {
        "path": "/api/v1/orders/{id}/status",
        "method": "PATCH",
        "description": "Update order status (e.g., cooking, ready).",
        "request_schema": {
          "status": "string",
          "bumpedBy": "string"
        },
        "response_schema": {
          "id": "string",
          "status": "string",
          "updatedAt": "string"
        },
        "auth_required": true,
        "rate_limit": "100 req/min"
      },
      {
        "path": "/api/v1/tables",
        "method": "GET",
        "description": "Get current floor plan status.",
        "request_schema": {},
        "response_schema": {
          "tables": "array"
        },
        "auth_required": true,
        "rate_limit": "60 req/min"
      },
      {
        "path": "/api/v1/payments/split",
        "method": "POST",
        "description": "Split a bill into multiple sub-payments.",
        "request_schema": {
          "orderId": "string",
          "splits": "array"
        },
        "response_schema": {
          "transactionIds": "array",
          "remainingBalance": "number"
        },
        "auth_required": true,
        "rate_limit": "20 req/min"
      }
    ],
    "summary": "A high-performance, event-driven platform utilizing React Native for offline-first POS operations and WebSockets for real-time Kitchen Display System synchronization, backed by a scalable PostgreSQL/Node.js architecture.",
    "description": "The system replaces legacy restaurant workflows with a cloud-native solution. It features a distributed architecture where POS tablets operate with local databases (WatermelonDB) to ensure service continuity during internet outages, synchronizing with the central backend via UUIDv7 keys. The backend leverages Redis Pub/Sub to instantly route orders to specific kitchen stations, ensuring the 'High Load Performance' acceptance criteria is met.",
    "decisions": [
      {
        "decision": "Use PostgreSQL as primary database",
        "status": "accepted",
        "reason": "ACID compliance is non-negotiable for financial transactions and inventory management. Relational model fits the structured nature of Menus, Orders, and Tables perfectly.",
        "tradeoffs": "Schema migrations can be painful compared to NoSQL; scaling writes requires vertical scaling or sharding.",
        "consequences": "Must implement strict migration pipelines; use JSONB columns for flexible menu modifiers.",
        "alternatives": [
          "MongoDB (rejected: lack of multi-document transactions in older versions, eventual consistency risks)",
          "Firebase (rejected: querying capabilities too limited for complex reporting)"
        ]
      },
      {
        "decision": "Implement UUIDv7 for Primary Keys",
        "status": "accepted",
        "reason": "Allows offline generation of IDs on the client side (POS) that are time-sortable, preventing collision during sync and maintaining index locality.",
        "tradeoffs": "Slightly larger storage footprint than integers; slightly slower insert performance than sequential integers.",
        "consequences": "Frontend must include UUID generation library; DB schema must use UUID type.",
        "alternatives": [
          "Auto-increment Integers (rejected: impossible to generate offline without collision)",
          "UUIDv4 (rejected: poor database index performance due to randomness)"
        ]
      },
      {
        "decision": "Use WebSockets (Socket.io) for KDS Sync",
        "status": "accepted",
        "reason": "Polling introduces latency unacceptable for a high-paced kitchen environment. WebSockets provide sub-200ms updates required by AC-1.",
        "tradeoffs": "Requires maintaining stateful connections; scaling requires Redis adapter for pub/sub across nodes.",
        "consequences": "Need to configure sticky sessions in load balancer or use a stateless transport fallback.",
        "alternatives": [
          "Short Polling (rejected: high server load, latency)",
          "Server-Sent Events (considered: good for one-way, but we need bi-directional for bumping)"
        ]
      },
      {
        "decision": "Logical Multi-Tenancy (Row-Level Security)",
        "status": "accepted",
        "reason": "Cost-effective for mid-sized market. Physical isolation (one DB per client) is operationally complex and expensive to maintain for thousands of small restaurants.",
        "tradeoffs": "Risk of data leak if `restaurant_id` filter is missed in queries; noisy neighbor problem.",
        "consequences": "Must implement rigorous testing of tenant isolation; use RLS policies in Postgres as a safety net.",
        "alternatives": [
          "Database-per-tenant (rejected: too expensive for target market)",
          "Schema-per-tenant (rejected: migration complexity)"
        ]
      }
    ],
    "database_schema": {
      "tables": [
        {
          "name": "restaurants",
          "columns": [
            {
              "name": "id",
              "type": "UUID",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "Tenant ID"
            },
            {
              "name": "name",
              "type": "VARCHAR(100)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Restaurant Name"
            },
            {
              "name": "settings",
              "type": "JSONB",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Config like tax rates, timezone"
            }
          ],
          "description": "Tenant configuration",
          "indexes": [
            {
              "columns": [
                "id"
              ],
              "type": "btree"
            }
          ],
          "relationships": []
        },
        {
          "name": "orders",
          "columns": [
            {
              "name": "id",
              "type": "UUID",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "UUIDv7"
            },
            {
              "name": "restaurant_id",
              "type": "UUID",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Tenant FK"
            },
            {
              "name": "table_id",
              "type": "UUID",
              "constraints": [
                "NULLABLE"
              ],
              "description": "Table FK"
            },
            {
              "name": "status",
              "type": "VARCHAR(20)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "OPEN, SENT, BILLED, CLOSED"
            },
            {
              "name": "total_amount",
              "type": "DECIMAL(10,2)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Final cost"
            }
          ],
          "description": "Head of the order ticket",
          "indexes": [
            {
              "columns": [
                "restaurant_id",
                "status"
              ],
              "type": "btree"
            }
          ],
          "relationships": [
            {
              "type": "many-to-one",
              "from": "restaurant_id",
              "to": "restaurants.id"
            },
            {
              "type": "many-to-one",
              "from": "table_id",
              "to": "tables.id"
            }
          ]
        },
        {
          "name": "order_items",
          "columns": [
            {
              "name": "id",
              "type": "UUID",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "UUIDv7"
            },
            {
              "name": "order_id",
              "type": "UUID",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Parent Order FK"
            },
            {
              "name": "menu_item_id",
              "type": "UUID",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Item FK"
            },
            {
              "name": "modifiers",
              "type": "JSONB",
              "constraints": [
                "DEFAULT '{}'"
              ],
              "description": "Customizations (No onions)"
            },
            {
              "name": "status",
              "type": "VARCHAR(20)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "PENDING, COOKING, READY"
            }
          ],
          "description": "Individual line items",
          "indexes": [
            {
              "columns": [
                "order_id"
              ],
              "type": "btree"
            }
          ],
          "relationships": [
            {
              "type": "many-to-one",
              "from": "order_id",
              "to": "orders.id"
            }
          ]
        },
        {
          "name": "tables",
          "columns": [
            {
              "name": "id",
              "type": "UUID",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "UUIDv7"
            },
            {
              "name": "restaurant_id",
              "type": "UUID",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Tenant FK"
            },
            {
              "name": "status",
              "type": "VARCHAR(20)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "OPEN, SEATED, DIRTY"
            },
            {
              "name": "coordinates",
              "type": "JSONB",
              "constraints": [
                "NOT NULL"
              ],
              "description": "x, y, rotation"
            }
          ],
          "description": "Physical layout configuration",
          "indexes": [
            {
              "columns": [
                "restaurant_id"
              ],
              "type": "btree"
            }
          ],
          "relationships": [
            {
              "type": "many-to-one",
              "from": "restaurant_id",
              "to": "restaurants.id"
            }
          ]
        }
      ]
    },
    "technology_stack": {
      "frontend": [
        "React Native (Tablets)",
        "React (KDS/Admin)",
        "TailwindCSS",
        "WatermelonDB (Offline)"
      ],
      "backend": [
        "Node.js",
        "NestJS",
        "Socket.io",
        "TypeScript"
      ],
      "database": [
        "PostgreSQL 15",
        "Redis (Pub/Sub & Cache)"
      ],
      "authentication": [
        "Auth0",
        "JWT"
      ],
      "hosting": [
        "AWS ECS (Fargate)",
        "AWS RDS",
        "AWS ElastiCache"
      ],
      "other": [
        "Stripe API",
        "Docker",
        "Terraform"
      ]
    },
    "security_considerations": [
      "PCI-DSS compliance via Stripe Elements (no raw card data touches server)",
      "Row-Level Security (RLS) in PostgreSQL to enforce tenant isolation",
      "WAF (Web Application Firewall) to prevent DDoS on WebSocket endpoints",
      "Short-lived JWTs for POS terminals with refresh token rotation"
    ],
    "scalability_approach": {
      "caching_strategy": "Redis for session storage and high-read menu data. CDN for static assets (images).",
      "database_scaling": "Read replicas for analytics/reporting queries. Connection pooling via PgBouncer.",
      "horizontal_scaling": "Stateless backend services scaled via AWS Auto Scaling Groups based on CPU/Memory.",
      "performance_targets": "API latency < 100ms, WebSocket broadcast < 200ms, 99.9% uptime."
    },
    "integration_points": [
      {
        "service": "Stripe Connect",
        "purpose": "Payment processing and split checks",
        "api_docs": "https://stripe.com/docs/api"
      },
      {
        "service": "SendGrid",
        "purpose": "Emailing digital receipts to customers",
        "api_docs": "https://docs.sendgrid.com/api-reference"
      },
      {
        "service": "Auth0",
        "purpose": "Identity management for staff and owners",
        "api_docs": "https://auth0.com/docs/api"
      }
    ]
  }
}