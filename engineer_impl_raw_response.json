{
  "step_id": "engineer_impl",
  "role": "Engineer",
  "content": {
    "summary": "A high-performance crypto trading terminal using a NestJS microservices backend and a React real-time dashboard. The system separates heavy data ingestion (CCXT) from user-facing APIs using Redis queues.",
    "description": "CryptoPulse is architected to handle the specific challenges of crypto portfolio tracking: high data fragmentation and real-time requirements. The solution uses a monorepo containing three main artifacts: a NestJS API Gateway for user management and serving data, a dedicated NestJS Worker service for handling heavy CCXT exchange interactions, and a React frontend optimized for data density. Data persistence is handled by PostgreSQL with TimescaleDB for efficient time-series storage, while Redis serves as the backbone for job queues and real-time price streaming.",
    "artifact_path": "cryptopulse-monorepo",
    "file_structure": {
      "name": "cryptopulse-monorepo",
      "type": "directory",
      "children": [
        {
          "name": "apps",
          "type": "directory"
        },
        {
          "name": "api",
          "type": "directory"
        },
        {
          "name": "src",
          "type": "directory"
        },
        {
          "name": "config",
          "type": "directory"
        },
        {
          "name": "database.config.ts",
          "type": "file"
        },
        {
          "name": "redis.config.ts",
          "type": "file"
        },
        {
          "name": "modules",
          "type": "directory"
        },
        {
          "name": "auth",
          "type": "directory"
        },
        {
          "name": "auth.controller.ts",
          "type": "file"
        },
        {
          "name": "auth.service.ts",
          "type": "file"
        },
        {
          "name": "jwt.strategy.ts",
          "type": "file"
        },
        {
          "name": "portfolio",
          "type": "directory"
        },
        {
          "name": "portfolio.controller.ts",
          "type": "file"
        },
        {
          "name": "portfolio.service.ts",
          "type": "file"
        },
        {
          "name": "keys",
          "type": "directory"
        },
        {
          "name": "keys.controller.ts",
          "type": "file"
        },
        {
          "name": "keys.service.ts",
          "type": "file"
        },
        {
          "name": "encryption.util.ts",
          "type": "file"
        },
        {
          "name": "market-stream",
          "type": "directory"
        },
        {
          "name": "market.gateway.ts",
          "type": "file"
        },
        {
          "name": "app.module.ts",
          "type": "file"
        },
        {
          "name": "main.ts",
          "type": "file"
        },
        {
          "name": "ingestion-worker",
          "type": "directory"
        },
        {
          "name": "src",
          "type": "directory"
        },
        {
          "name": "processors",
          "type": "directory"
        },
        {
          "name": "sync-portfolio.processor.ts",
          "type": "file"
        },
        {
          "name": "sync-history.processor.ts",
          "type": "file"
        },
        {
          "name": "adapters",
          "type": "directory"
        },
        {
          "name": "ccxt.service.ts",
          "type": "file"
        },
        {
          "name": "worker.module.ts",
          "type": "file"
        },
        {
          "name": "main.ts",
          "type": "file"
        },
        {
          "name": "web",
          "type": "directory"
        },
        {
          "name": "src",
          "type": "directory"
        },
        {
          "name": "assets",
          "type": "directory"
        },
        {
          "name": "components",
          "type": "directory"
        },
        {
          "name": "charts",
          "type": "directory"
        },
        {
          "name": "TradingViewChart.tsx",
          "type": "file"
        },
        {
          "name": "dashboard",
          "type": "directory"
        },
        {
          "name": "PortfolioSummary.tsx",
          "type": "file"
        },
        {
          "name": "AssetTable.tsx",
          "type": "file"
        },
        {
          "name": "layout",
          "type": "directory"
        },
        {
          "name": "Sidebar.tsx",
          "type": "file"
        },
        {
          "name": "hooks",
          "type": "directory"
        },
        {
          "name": "useSocket.ts",
          "type": "file"
        },
        {
          "name": "useAuth.ts",
          "type": "file"
        },
        {
          "name": "store",
          "type": "directory"
        },
        {
          "name": "usePortfolioStore.ts",
          "type": "file"
        },
        {
          "name": "useMarketDataStore.ts",
          "type": "file"
        },
        {
          "name": "pages",
          "type": "directory"
        },
        {
          "name": "Dashboard.tsx",
          "type": "file"
        },
        {
          "name": "Settings.tsx",
          "type": "file"
        },
        {
          "name": "App.tsx",
          "type": "file"
        },
        {
          "name": "main.tsx",
          "type": "file"
        },
        {
          "name": "libs",
          "type": "directory"
        },
        {
          "name": "shared-types",
          "type": "directory"
        },
        {
          "name": "src",
          "type": "directory"
        },
        {
          "name": "index.ts",
          "type": "file"
        },
        {
          "name": "dto",
          "type": "directory"
        },
        {
          "name": "trade.dto.ts",
          "type": "file"
        },
        {
          "name": "docker-compose.yml",
          "type": "file"
        },
        {
          "name": "package.json",
          "type": "file"
        },
        {
          "name": "tsconfig.base.json",
          "type": "file"
        }
      ]
    },
    "implementation_plan": "# CryptoPulse Implementation Plan\n\n## Phase 1: Infrastructure & Monorepo Setup\n1. **Initialize Monorepo**: Set up a workspace (Nx or Turborepo) to manage `apps/api`, `apps/ingestion-worker`, and `apps/web`.\n2. **Database Provisioning**: Configure `docker-compose.yml` with PostgreSQL (TimescaleDB image) and Redis.\n3. **Shared Libraries**: Create `libs/shared-types` to hold DTOs and interfaces shared between backend and frontend.\n\n## Phase 2: Core Backend (API Service)\n1. **Auth Module**: Implement JWT authentication using Passport.js. Create User entity and migration.\n2. **Key Management**: Implement `KeysModule` with AES-256 encryption. Create endpoints to securely receive and store API keys.\n3. **Database Schema**: Define TypeORM entities for `User`, `ExchangeKey`, `Trade`, and `PortfolioSnapshot`. Enable TimescaleDB hypertables for snapshots.\n\n## Phase 3: Ingestion Engine (Worker Service)\n1. **CCXT Integration**: Create a service wrapper around CCXT to normalize calls across Binance, Coinbase, etc.\n2. **Queue Setup**: Configure BullMQ in both API (producer) and Worker (consumer). Define queues: `sync-balance`, `sync-history`.\n3. **Sync Logic**: Implement the processor to fetch balances, decrypt keys (in memory only), and update the DB. Handle rate limits using CCXT's built-in throttling or a custom Redis limiter.\n\n## Phase 4: Real-Time Data Streaming\n1. **Market Data Service**: Implement a service in the API app that connects to public Exchange WebSockets for price feeds.\n2. **Redis Pub/Sub**: Publish price updates to Redis channels (e.g., `ticker:BTC/USDT`).\n3. **WebSocket Gateway**: Create a NestJS Gateway (`socket.io`) that subscribes to Redis and broadcasts updates to connected frontend clients.\n\n## Phase 5: Frontend Dashboard\n1. **Shell & Auth**: Setup React with Tailwind CSS. Implement Login/Register pages and JWT storage.\n2. **State Management**: Configure Zustand stores. `usePortfolioStore` for user data, `useMarketDataStore` for high-frequency price updates.\n3. **Charts**: Integrate `lightweight-charts`. Create a wrapper component to render candles and overlays.\n4. **Dashboard Widgets**: Build components for Total Balance (donut chart), Recent Trades (table), and Active Alerts.\n\n## Phase 6: Advanced Features & Polish\n1. **PnL Calculation**: Implement the logic to calculate Realized vs Unrealized PnL based on trade history (FIFO method).\n2. **Alerts System**: Implement a background job to check price thresholds against Redis cache and trigger notifications.\n3. **Tax Report**: Create a basic CSV export generator for trade history.\n4. **Security Audit**: Verify encryption at rest and ensure API keys are never sent to the client.",
    "dependencies": [
      "@nestjs/core",
      "@nestjs/common",
      "@nestjs/platform-socket.io",
      "@nestjs/typeorm",
      "@nestjs/passport",
      "@nestjs/bullmq",
      "typeorm",
      "pg",
      "passport",
      "passport-jwt",
      "bcrypt",
      "ccxt",
      "bullmq",
      "ioredis",
      "socket.io",
      "class-validator",
      "react",
      "react-dom",
      "zustand",
      "lightweight-charts",
      "socket.io-client",
      "axios",
      "tailwindcss",
      "date-fns",
      "recharts"
    ],
    "technical_decisions": [
      {
        "decision": "Monorepo Structure",
        "rationale": "Allows sharing of TypeScript interfaces (DTOs) between the API, Worker, and Frontend, ensuring type safety across the entire stack.",
        "alternatives": "Separate repositories for each service."
      },
      {
        "decision": "CCXT for Exchange Integration",
        "rationale": "Reduces the complexity of maintaining 10+ different exchange API implementations. CCXT normalizes responses, saving hundreds of dev hours.",
        "alternatives": "Custom HTTP wrappers for each exchange."
      },
      {
        "decision": "TimescaleDB",
        "rationale": "We need relational data (Users, Keys) alongside time-series data (Portfolio Snapshots, Candles). TimescaleDB allows us to use a single Postgres instance for both.",
        "alternatives": "InfluxDB + PostgreSQL (Two separate DBs to manage)."
      },
      {
        "decision": "BullMQ (Redis Queues)",
        "rationale": "Fetching trade history is slow and rate-limited. Offloading this to a background worker queue prevents the main API from blocking.",
        "alternatives": "Kafka (Overkill), RabbitMQ."
      },
      {
        "decision": "Zustand for Frontend State",
        "rationale": "Lightweight and unopinionated. Handles high-frequency updates (like price tickers) better than Context API and with less boilerplate than Redux.",
        "alternatives": "Redux Toolkit, React Context."
      }
    ],
    "environment_variables": [
      {
        "name": "DATABASE_URL",
        "description": "Connection string for PostgreSQL/TimescaleDB",
        "example": "postgres://user:pass@localhost:5432/cryptopulse"
      },
      {
        "name": "REDIS_URL",
        "description": "Connection string for Redis",
        "example": "redis://localhost:6379"
      },
      {
        "name": "JWT_SECRET",
        "description": "Secret key for signing JSON Web Tokens",
        "example": "super_secret_jwt_key_123"
      },
      {
        "name": "ENCRYPTION_MASTER_KEY",
        "description": "32-byte hex string used to encrypt user API keys",
        "example": "a1b2c3d4..."
      },
      {
        "name": "PORT",
        "description": "API Server Port",
        "example": "3000"
      }
    ],
    "technical_patterns": [
      "Microservices (Worker/API split)",
      "Event-Driven Architecture",
      "Repository Pattern (TypeORM)",
      "Adapter Pattern (CCXT Wrapper)",
      "Envelope Encryption"
    ],
    "state_management": {
      "tool": "Zustand",
      "strategy": "Split stores: 'UserStore' for persistent auth/settings, 'PortfolioStore' for async data fetching, and 'MarketStore' for ephemeral high-frequency WebSocket updates."
    },
    "run_results": {
      "setup_commands": [
        "npm install",
        "docker-compose up -d",
        "npm run typeorm:migration:run"
      ],
      "test_commands": [
        "npm run test:api",
        "npm run test:worker",
        "npm run test:web"
      ],
      "dev_commands": [
        "npm run start:dev:api",
        "npm run start:dev:worker",
        "npm run start:dev:web"
      ]
    }
  }
}