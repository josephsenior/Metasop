{
  "step_id": "arch_design",
  "role": "Architect",
  "content": {
    "design_doc": "# CryptoPulse System Architecture\n\n## 1. System Overview\nCryptoPulse is a non-custodial, multi-exchange trading terminal. The system acts as a secure proxy and aggregation layer between the user and various cryptocurrency exchanges (Binance, Coinbase, Kraken, etc.). The core value proposition is normalizing fragmented data (balances, prices, order books) into a unified schema and providing a low-latency execution environment.\n\n## 2. Architecture Patterns\nWe will utilize a **Event-Driven Microservices Architecture** (or Modular Monolith for MVP phase) centered around a **Normalization Layer**.\n\n### Core Components:\n1.  **API Gateway / Load Balancer**: Entry point for REST and WebSocket connections.\n2.  **Core API Service (NestJS)**: Handles user authentication, portfolio management, and order routing logic.\n3.  **Market Data Engine**: A specialized service using the CCXT library to connect to external Exchange WebSockets, normalize the payloads, and push updates to our internal Event Bus.\n4.  **Execution Engine**: Handles the lifecycle of trade orders, including validation, submission to exchanges, and monitoring for fill status.\n5.  **Notification Service**: Background worker for processing price alerts and sending emails/push notifications.\n\n## 3. Data Flow\n1.  **Data Ingestion**: The Market Data Engine subscribes to external exchange WebSockets. Incoming data is normalized to a standard internal format.\n2.  **Real-time Distribution**: Normalized data is published to Redis Pub/Sub. The Core API (via WebSocket Gateway) subscribes to these channels and pushes updates to connected frontend clients.\n3.  **Order Execution**: \n    - User submits order -> Core API validates balance/permissions.\n    - Order is encrypted and passed to Execution Engine.\n    - Execution Engine decrypts keys (in memory only), calls Exchange API, and updates local DB with status.\n\n## 4. Security Architecture\n-   **Zero-Knowledge Storage**: We do not store funds. We only store API credentials.\n-   **Envelope Encryption**: API Secrets are encrypted using AES-256-GCM. The Data Encryption Key (DEK) is stored in the database, but the Key Encryption Key (KEK) is managed via AWS KMS. This ensures that a database dump is useless without the KMS permissions.\n-   **Isolation**: The service handling decryption for signing requests is isolated from the public-facing API.\n\n## 5. Scalability\n-   **Stateless Services**: The API and Data Engine are stateless, allowing horizontal scaling behind a load balancer.\n-   **Redis Backplane**: Used for distributing WebSocket events across multiple API nodes.\n-   **Rate Limit Management**: A distributed semaphore system (Redis-based) tracks usage per exchange/per user to respect external API limits.",
    "apis": [
      {
        "path": "/api/v1/auth/login",
        "method": "POST",
        "description": "Authenticates user and returns JWT + Refresh Token.",
        "request_schema": {
          "email": "string",
          "password": "string",
          "totp_code": "string (optional)"
        },
        "response_schema": {
          "access_token": "string",
          "refresh_token": "string",
          "user": {
            "id": "uuid",
            "email": "string"
          }
        },
        "auth_required": false,
        "rate_limit": "5 requests/minute"
      },
      {
        "path": "/api/v1/exchanges/connections",
        "method": "POST",
        "description": "Adds a new exchange API key connection. Validates keys before saving.",
        "request_schema": {
          "exchange_id": "string (binance, coinbase)",
          "api_key": "string",
          "api_secret": "string",
          "connection_name": "string"
        },
        "response_schema": {
          "id": "uuid",
          "status": "active",
          "exchange_id": "string"
        },
        "auth_required": true,
        "rate_limit": "10 requests/hour"
      },
      {
        "path": "/api/v1/portfolio/summary",
        "method": "GET",
        "description": "Get aggregated portfolio balance converted to base currency.",
        "request_schema": {},
        "response_schema": {
          "total_balance_usd": "number",
          "assets": [
            {
              "symbol": "string",
              "amount": "number",
              "usd_value": "number",
              "exchange": "string"
            }
          ]
        },
        "auth_required": true,
        "rate_limit": "60 requests/minute"
      },
      {
        "path": "/api/v1/orders",
        "method": "POST",
        "description": "Place a new order on a specific exchange.",
        "request_schema": {
          "connection_id": "uuid",
          "symbol": "string (BTC/USDT)",
          "side": "string (buy|sell)",
          "type": "string (limit|market)",
          "amount": "number",
          "price": "number (optional)"
        },
        "response_schema": {
          "order_id": "string",
          "external_id": "string",
          "status": "open",
          "filled": "number"
        },
        "auth_required": true,
        "rate_limit": "20 requests/minute"
      },
      {
        "path": "/api/v1/market/candles",
        "method": "GET",
        "description": "Proxy endpoint to fetch historical OHLCV data for charts.",
        "request_schema": {
          "exchange": "string",
          "symbol": "string",
          "timeframe": "string (1h, 4h)",
          "limit": "number"
        },
        "response_schema": {
          "candles": [
            [
              1620000000,
              50000,
              51000,
              49000,
              50500,
              100
            ]
          ]
        },
        "auth_required": true,
        "rate_limit": "100 requests/minute"
      }
    ],
    "summary": "CryptoPulse utilizes a secure, event-driven Node.js architecture to aggregate crypto exchange data. By leveraging CCXT for normalization and Redis for real-time distribution, it provides a unified trading experience. Security is anchored by AWS KMS envelope encryption for user API keys.",
    "description": "The system is designed as a high-performance aggregator. The backend is built with NestJS, providing a structured and type-safe environment. The critical challenge is managing connections to multiple third-party exchanges (Binance, Kraken, etc.) which have different API standards. We solve this using the CCXT library wrapped in a custom service layer. \n\nData flow starts with the 'Market Data Engine' ingesting WebSocket feeds. This data is normalized and pushed to Redis Pub/Sub. The 'API Gateway' subscribes to these channels and forwards updates to the React frontend via Socket.io. \n\nFor execution, the system acts as a router. It validates the user's intent and permissions locally, decrypts the stored API keys using a master key from AWS KMS, signs the request, and forwards it to the specific exchange. This ensures that the platform is non-custodial and secure.",
    "decisions": [
      {
        "decision": "Use CCXT Library for Exchange Integration",
        "status": "accepted",
        "reason": "CCXT is the industry standard open-source library supporting 100+ exchanges. It handles the normalization of API responses, error codes, and signing algorithms.",
        "rationale": "Efficiency and maintainability are key for an aggregator.",
        "tradeoffs": "Dependency on a large third-party library. Updates to exchanges might lag slightly behind official APIs, but the community is very active.",
        "consequences": "Drastically reduces development time for adding new exchanges. We only write code against the CCXT interface, not individual exchange REST APIs.",
        "alternatives": [
          "Build custom adapters for each exchange",
          "Use a paid aggregation API (e.g., Shrimpy) - rejected due to cost and vendor lock-in"
        ]
      },
      {
        "decision": "Envelope Encryption for API Secrets",
        "status": "accepted",
        "reason": "Storing API secrets in plain text is a critical vulnerability. Database encryption alone is insufficient if the DB is compromised.",
        "rationale": "Security is a 'must-have' for a fintech product.",
        "tradeoffs": "Adds latency to every authenticated exchange request due to the decryption step. Requires key management infrastructure (AWS KMS).",
        "consequences": "High security assurance. Even if the DB is leaked, the attacker cannot use the API keys without the master key from KMS.",
        "alternatives": [
          "Database-level encryption (TDE)",
          "Hashicorp Vault (too complex for current scale)"
        ]
      },
      {
        "decision": "Redis Pub/Sub for Real-time Data",
        "status": "accepted",
        "reason": "We need to broadcast price updates from the ingestion service to multiple frontend clients connected via WebSockets.",
        "rationale": "Redis is fast, simple, and sufficient for the throughput.",
        "tradeoffs": "Redis becomes a critical infrastructure component. If Redis fails, real-time updates stop.",
        "consequences": "Decouples the data fetching logic from the client connection handling. Allows scaling WebSocket servers horizontally.",
        "alternatives": [
          "Kafka (overkill for ephemeral price ticks)",
          "Direct memory event bus (doesn't scale across nodes)"
        ]
      }
    ],
    "next_tasks": [
      {
        "role": "DevOps",
        "task": "Setup AWS KMS and Database Infrastructure",
        "description": "Provision RDS (Postgres), ElastiCache (Redis), and create the KMS Customer Master Key (CMK) for encryption.",
        "priority": "high",
        "title": "Infra Setup"
      },
      {
        "role": "Engineer",
        "task": "Implement CCXT Wrapper Service",
        "description": "Create the backend module that wraps CCXT, handles rate limiting, and normalizes the 'fetchBalance' and 'createOrder' calls.",
        "priority": "high",
        "title": "Exchange Adapter"
      },
      {
        "role": "Engineer",
        "task": "Develop Encryption/Decryption Utilities",
        "description": "Implement the AES-256-GCM logic using the KMS key for encrypting user API secrets before storage.",
        "priority": "high",
        "title": "Security Module"
      },
      {
        "role": "Designer",
        "task": "Design Dashboard Layout",
        "description": "Create high-fidelity mockups for the portfolio overview and trading terminal view, focusing on dense data visualization.",
        "priority": "medium",
        "title": "UI Design"
      },
      {
        "role": "QA",
        "task": "Create Exchange Mock Server",
        "description": "Build a mock server that simulates Binance/Coinbase APIs to test error handling and rate limits without using real funds.",
        "priority": "medium",
        "title": "Test Harness"
      }
    ],
    "database_schema": {
      "migrations_strategy": "TypeORM Migrations",
      "tables": [
        {
          "name": "users",
          "columns": [
            {
              "name": "id",
              "type": "uuid",
              "constraints": [
                "PRIMARY KEY",
                "DEFAULT uuid_generate_v4()"
              ],
              "description": "Unique user identifier"
            },
            {
              "name": "email",
              "type": "varchar",
              "constraints": [
                "UNIQUE",
                "NOT NULL"
              ],
              "description": "User email address"
            },
            {
              "name": "password_hash",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Bcrypt hash"
            },
            {
              "name": "two_factor_secret",
              "type": "varchar",
              "constraints": [],
              "description": "Encrypted TOTP secret"
            }
          ],
          "description": "Core user identity table",
          "indexes": [],
          "relationships": []
        },
        {
          "name": "exchange_connections",
          "columns": [
            {
              "name": "id",
              "type": "uuid",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "Connection ID"
            },
            {
              "name": "user_id",
              "type": "uuid",
              "constraints": [
                "NOT NULL",
                "FOREIGN KEY"
              ],
              "description": "Owner of the connection"
            },
            {
              "name": "exchange_id",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "CCXT exchange ID (e.g., 'binance')"
            },
            {
              "name": "api_key_ciphertext",
              "type": "text",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Encrypted API Key"
            },
            {
              "name": "api_secret_ciphertext",
              "type": "text",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Encrypted API Secret"
            },
            {
              "name": "label",
              "type": "varchar",
              "constraints": [],
              "description": "User defined label"
            }
          ],
          "description": "Stores credentials for external exchanges",
          "indexes": [
            {
              "columns": [
                "user_id"
              ],
              "reason": "Frequent lookup for portfolio aggregation",
              "type": "btree"
            }
          ],
          "relationships": [
            {
              "type": "many-to-one",
              "from": "user_id",
              "to": "users.id",
              "description": "User owns connections"
            }
          ]
        },
        {
          "name": "orders",
          "columns": [
            {
              "name": "id",
              "type": "uuid",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "Internal Order ID"
            },
            {
              "name": "connection_id",
              "type": "uuid",
              "constraints": [
                "NOT NULL",
                "FOREIGN KEY"
              ],
              "description": "Which exchange connection used"
            },
            {
              "name": "external_order_id",
              "type": "varchar",
              "constraints": [],
              "description": "ID assigned by the exchange"
            },
            {
              "name": "symbol",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Trading pair (e.g. BTC/USD)"
            },
            {
              "name": "status",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "open, closed, canceled, failed"
            },
            {
              "name": "side",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "buy or sell"
            },
            {
              "name": "amount",
              "type": "decimal(24,12)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Order size"
            }
          ],
          "description": "Local record of orders placed via the platform",
          "indexes": [
            {
              "columns": [
                "connection_id",
                "status"
              ],
              "reason": "Filtering active orders",
              "type": "btree"
            }
          ],
          "relationships": [
            {
              "type": "many-to-one",
              "from": "connection_id",
              "to": "exchange_connections.id",
              "description": "Order belongs to a connection"
            }
          ]
        },
        {
          "name": "alerts",
          "columns": [
            {
              "name": "id",
              "type": "uuid",
              "constraints": [
                "PRIMARY KEY"
              ],
              "description": "Alert ID"
            },
            {
              "name": "user_id",
              "type": "uuid",
              "constraints": [
                "NOT NULL"
              ],
              "description": "User ID"
            },
            {
              "name": "symbol",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Target symbol"
            },
            {
              "name": "target_price",
              "type": "decimal(24,12)",
              "constraints": [
                "NOT NULL"
              ],
              "description": "Price threshold"
            },
            {
              "name": "condition",
              "type": "varchar",
              "constraints": [
                "NOT NULL"
              ],
              "description": "gt (greater than) or lt (less than)"
            },
            {
              "name": "is_active",
              "type": "boolean",
              "constraints": [
                "DEFAULT true"
              ],
              "description": "Enabled status"
            }
          ],
          "description": "User configured price alerts",
          "indexes": [],
          "relationships": []
        }
      ]
    },
    "technology_stack": {
      "authentication": [
        "JWT (JSON Web Tokens)",
        "Passport.js",
        "TOTP (2FA)"
      ],
      "backend": [
        "Node.js",
        "NestJS (Framework)",
        "TypeScript",
        "CCXT (Crypto Library)"
      ],
      "database": [
        "PostgreSQL 15 (Primary Data)",
        "Redis 7 (Cache & Pub/Sub)"
      ],
      "frontend": [
        "React 18",
        "TypeScript",
        "Tailwind CSS",
        "Lightweight Charts (TradingView)",
        "Zustand (State Management)"
      ],
      "hosting": [
        "AWS ECS (Fargate)",
        "AWS RDS",
        "AWS ElastiCache"
      ],
      "other": [
        "AWS KMS (Key Management)",
        "Socket.io (WebSockets)",
        "BullMQ (Job Queue for Alerts)"
      ]
    },
    "integration_points": [
      {
        "service": "Binance API",
        "purpose": "Market data and order execution",
        "api_docs": "https://binance-docs.github.io/apidocs/",
        "name": "Binance",
        "system": "External Exchange"
      },
      {
        "service": "Coinbase Pro API",
        "purpose": "Market data and order execution",
        "api_docs": "https://docs.cloud.coinbase.com/exchange/docs/",
        "name": "Coinbase",
        "system": "External Exchange"
      },
      {
        "service": "AWS KMS",
        "purpose": "Encryption of API Secrets",
        "api_docs": "https://docs.aws.amazon.com/kms/",
        "name": "Key Management Service",
        "system": "AWS"
      },
      {
        "service": "SendGrid",
        "purpose": "Transactional emails (Alerts, 2FA)",
        "api_docs": "https://docs.sendgrid.com/api-reference",
        "name": "SendGrid",
        "system": "Email Provider"
      }
    ],
    "security_considerations": [
      "API Keys must never be logged in plain text in application logs.",
      "Implement strict Content Security Policy (CSP) to prevent XSS, which could steal session tokens.",
      "Use 'httpOnly' and 'Secure' cookies for session management to mitigate XSS token theft.",
      "Rate limiting must be applied per IP and per User ID to prevent DDoS and brute force attacks.",
      "All internal communication between services (if split) should be over mTLS or private VPC subnets."
    ],
    "scalability_approach": {
      "caching_strategy": "Redis will cache 'Ticker' and 'OrderBook' data with a short TTL (1-5 seconds) to serve high-frequency read requests without hitting exchange rate limits.",
      "database_scaling": "Read Replicas for PostgreSQL will be used for the 'Tax Export' and 'History' features to offload heavy analytical queries from the primary writer node.",
      "horizontal_scaling": "The Node.js API layer is stateless and can be autoscaled based on CPU/Memory usage. WebSocket servers will use a Redis Adapter to broadcast messages across multiple instances.",
      "performance_targets": "API response time < 100ms for cached data. WebSocket latency < 200ms from exchange ingestion to client push."
    }
  }
}