import type { Diagram } from "@/types/diagram"

export class SQLGenerator {
  private diagram: Diagram
  private artifacts: any

  constructor(diagram: Diagram) {
    this.diagram = diagram
    this.artifacts = diagram.metadata?.metasop_artifacts || {}
  }

  /**
   * Generate SQL migration script
   */
  generateMigration(): string {
    const archContent = this.artifacts.arch_design?.content || {}
    const schema = archContent.database_schema || {}
    const tables = schema.tables || []
    const tablesArray = Array.isArray(tables) ? tables : []

    let sql = `-- Migration generated by ArchitectAI
-- Generated: ${new Date().toISOString()}
-- Diagram: ${this.diagram.title}

BEGIN;

`

    // Generate CREATE TABLE statements
    tablesArray.forEach((table: any) => {
      const tableName = table.table_name || table.name || "table"
      sql += `-- Table: ${tableName}\n`
      sql += `CREATE TABLE IF NOT EXISTS "${tableName}" (\n`

      if (table.columns) {
        const columns = Array.isArray(table.columns) ? table.columns : []
        const columnDefs: string[] = []

        columns.forEach((col: any, idx: number) => {
          const colName = typeof col === "object" ? col.name : col
          const colType = typeof col === "object" ? col.type || "VARCHAR(255)" : "VARCHAR(255)"
          const constraints = typeof col === "object" && col.constraints
            ? (Array.isArray(col.constraints) ? col.constraints : [col.constraints])
            : []

          let def = `  "${colName}" ${this.normalizeSqlType(colType)}`

          // Add constraints
          if (constraints.includes("PRIMARY KEY") || idx === 0) {
            def += " PRIMARY KEY"
          }
          if (constraints.includes("NOT NULL") && !constraints.includes("PRIMARY KEY")) {
            def += " NOT NULL"
          }
          if (constraints.includes("UNIQUE")) {
            def += " UNIQUE"
          }

          columnDefs.push(def)
        })

        // Add timestamps
        columnDefs.push(`  "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL`)
        columnDefs.push(`  "updatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL`)

        sql += columnDefs.join(",\n")
      }

      sql += `\n);\n\n`

      // Generate indexes
      if (table.columns) {
        const columns = Array.isArray(table.columns) ? table.columns : []
        columns.forEach((col: any) => {
          if (typeof col === "object" && col.constraints) {
            const constraints = Array.isArray(col.constraints) ? col.constraints : [col.constraints]
            if (constraints.includes("INDEX")) {
              const colName = col.name
              sql += `CREATE INDEX IF NOT EXISTS "idx_${tableName}_${colName}" ON "${tableName}" ("${colName}");\n`
            }
          }
        })
        sql += `\n`
      }
    })

    // Generate foreign keys if relationships exist
    const edges = this.diagram.edges || []
    edges.forEach((edge: any) => {
      const fromNode = this.diagram.nodes.find(n => n.id === edge.from)
      const toNode = this.diagram.nodes.find(n => n.id === edge.to)

      if (fromNode?.type === "database" && toNode?.type === "database") {
        const fromTable = fromNode.label.toLowerCase().replace(/\s+/g, "_")
        const toTable = toNode.label.toLowerCase().replace(/\s+/g, "_")
        
        sql += `-- Foreign key relationship: ${fromTable} -> ${toTable}\n`
        sql += `-- ALTER TABLE "${fromTable}" ADD CONSTRAINT "fk_${fromTable}_${toTable}" FOREIGN KEY ("${toTable}Id") REFERENCES "${toTable}"("id") ON DELETE CASCADE;\n\n`
      }
    })

    sql += `COMMIT;\n`

    return sql
  }

  /**
   * Generate seed data SQL
   */
  generateSeedData(): string {
    const archContent = this.artifacts.arch_design?.content || {}
    const schema = archContent.database_schema || {}
    const tables = schema.tables || []
    const tablesArray = Array.isArray(tables) ? tables : []

    let sql = `-- Seed data generated by ArchitectAI
-- Generated: ${new Date().toISOString()}

BEGIN;

`

    tablesArray.forEach((table: any) => {
      const tableName = table.table_name || table.name || "table"
      sql += `-- Seed data for ${tableName}\n`
      sql += `-- INSERT INTO "${tableName}" (column1, column2) VALUES ('value1', 'value2');\n\n`
    })

    sql += `COMMIT;\n`

    return sql
  }

  private normalizeSqlType(type: string): string {
    const normalized = type.toUpperCase()
    
    // Map common types
    if (normalized.includes("INT")) return "INTEGER"
    if (normalized.includes("VARCHAR")) return normalized
    if (normalized.includes("TEXT")) return "TEXT"
    if (normalized.includes("BOOL")) return "BOOLEAN"
    if (normalized.includes("DATE")) return "DATE"
    if (normalized.includes("TIME")) return "TIMESTAMP"
    if (normalized.includes("FLOAT") || normalized.includes("DOUBLE") || normalized.includes("DECIMAL")) {
      return "DECIMAL(10, 2)"
    }
    
    return normalized || "VARCHAR(255)"
  }
}

