import type { Diagram } from "@/types/diagram"

/**
 * Enhanced CodeGenerator that leverages MetaSOP multi-agent artifacts
 */
export class CodeGenerator {
  private diagram: Diagram
  private artifacts: any

  constructor(diagram: Diagram) {
    this.diagram = diagram
    this.artifacts = diagram.metadata?.metasop_artifacts || {}
  }

  /**
   * Generate project scaffolding as ZIP file
   */
  async generateProjectScaffold(): Promise<Blob> {
    // Dynamically import JSZip to avoid SSR issues
    const JSZip = (await import("jszip")).default
    const zip = new JSZip()

    // Extract artifacts with type safety
    const engineerArtifact = this.artifacts.engineer_impl?.content || {}
    const archContent = this.artifacts.arch_design?.content || {}
    const uiDesignerArtifact = this.artifacts.ui_design?.content || {}

    const rootDir = engineerArtifact.artifact_path || this.diagram.title.toLowerCase().replace(/\s+/g, "-")
    const folder =
      typeof (zip as any).folder === "function"
        ? (zip as any).folder(rootDir) || zip
        : zip

    // 1. Generate package.json
    folder.file("package.json", this.generatePackageJson(engineerArtifact))

    // 2. Generate tsconfig.json
    folder.file("tsconfig.json", this.generateTsConfig())

    // 3. Generate README.md (Enriched with implementation plan)
    folder.file("README.md", this.generateReadme(engineerArtifact))

    // 4. Generate file structure from Engineer
    if (engineerArtifact.file_structure) {
      this.generateFileStructure(folder, engineerArtifact.file_structure, "")
    }

    // 5. Generate API routes from Architect
    if (archContent.apis && archContent.apis.length > 0) {
      this.generateAPIRoutes(folder, archContent.apis)
    }

    // 6. Generate database schema from Architect
    if (archContent.database_schema) {
      this.generateDatabaseSchema(folder, archContent.database_schema)
    }

    // 7. Generate components from UI Designer
    if (uiDesignerArtifact.component_hierarchy) {
      this.generateComponents(folder, uiDesignerArtifact.component_hierarchy)
    }

    // 8. Generate environment variables template
    if (engineerArtifact.environment_variables && engineerArtifact.environment_variables.length > 0) {
      this.generateEnvTemplate(folder, engineerArtifact.environment_variables)
    }

    // 9. Generate Docker & Compose files
    this.generateDockerFiles(folder)

    return await zip.generateAsync({ type: "blob" })
  }

  private generatePackageJson(engineerArtifact: any): string {
    const dependencies = engineerArtifact.dependencies || []
    const deps: Record<string, string> = {}

    dependencies.forEach((dep: string) => {
      const [name, version] = dep.split("@")
      deps[name] = version || "latest"
    })

    // Meta-defaults for modern stack if missing
    if (Object.keys(deps).length === 0) {
      deps["next"] = "latest"
      deps["react"] = "latest"
      deps["react-dom"] = "latest"
      deps["lucide-react"] = "latest"
    }

    const scripts = {
      "dev": engineerArtifact.run_results?.dev_commands?.[0] || "next dev",
      "build": "next build",
      "start": "next start",
      "lint": "next lint",
      "test": engineerArtifact.run_results?.test_commands?.[0] || "vitest",
      "setup": engineerArtifact.run_results?.setup_commands?.join(" && ") || "npm install"
    }

    return JSON.stringify({
      name: this.diagram.title.toLowerCase().replace(/\s+/g, "-"),
      version: "0.1.0",
      description: this.diagram.description || "Project scaffold generated by MetaSOP",
      private: true,
      scripts,
      dependencies: deps,
      devDependencies: {
        "@types/node": "^20",
        "@types/react": "^19",
        "@types/react-dom": "^19",
        "typescript": "^5",
        "postcss": "^8",
        "tailwindcss": "^3"
      },
    }, null, 2)
  }

  private generateTsConfig(): string {
    return JSON.stringify({
      compilerOptions: {
        target: "ES2020",
        lib: ["dom", "dom.iterable", "esnext"],
        allowJs: true,
        skipLibCheck: true,
        strict: true,
        noEmit: true,
        esModuleInterop: true,
        module: "esnext",
        moduleResolution: "bundler",
        resolveJsonModule: true,
        isolatedModules: true,
        jsx: "preserve",
        incremental: true,
        plugins: [{ name: "next" }],
        paths: { "@/*": ["./*"] },
      },
      include: ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
      exclude: ["node_modules"],
    }, null, 2)
  }

  private generateReadme(engineerArtifact: any): string {
    return `# ${this.diagram.title}

${this.diagram.description}

Generated by **MetaSOP Multi-Agent Platform**.

## ðŸš€ Getting Started

### Installation
\`\`\`bash
${engineerArtifact.run_results?.setup_commands?.join("\n") || "npm install"}
\`\`\`

### Execution
- **Development**: \`${engineerArtifact.run_results?.dev_commands?.[0] || "npm run dev"}\`
- **Testing**: \`${engineerArtifact.run_results?.test_commands?.[0] || "npm test"}\`

## ðŸ“– Implementation Roadmap

${engineerArtifact.implementation_plan_phases && engineerArtifact.implementation_plan_phases.length > 0
        ? engineerArtifact.implementation_plan_phases
          .map((phase: any, index: number) => `### Phase ${index + 1}: ${phase.name}\n${phase.description || ""}\n${Array.isArray(phase.tasks) && phase.tasks.length > 0 ? phase.tasks.map((task: string) => `- ${task}`).join("\n") : ""}`)
          .join("\n\n")
        : "Implementation roadmap available in documentation."}

## âš™ï¸ Technical Decisions

${engineerArtifact.technical_decisions
        ? engineerArtifact.technical_decisions.map((d: any) => `### ${d.decision}\n**Rationale**: ${d.rationale}`).join("\n\n")
        : "Decisions finalized during architecture phase."}

---
*Created using ArchitectAI*
`
  }

  private generateFileStructure(zip: any, node: any, path: string) {
    const name = node.name || node.file || "unknown"
    const isFolder = node.type === "directory" || node.type === "folder" || (node.children && node.children.length > 0)
    const fullPath = path ? `${path}/${name}` : name

    if (isFolder) {
      if (node.children && Array.isArray(node.children)) {
        node.children.forEach((child: any) => {
          this.generateFileStructure(zip, child, fullPath)
        })
      } else {
        // Create an empty folder entry
        zip.file(`${fullPath}/.gitkeep`, "")
      }
    } else {
      const content = this.generateFileContent(node, fullPath)
      zip.file(fullPath, content)
    }
  }

  private generateFileContent(node: any, path: string): string {
    const ext = path.split(".").pop()?.toLowerCase() || ""

    switch (ext) {
      case "tsx":
      case "ts":
        return this.generateTypeScriptFile(node, path)
      case "md":
        return `# ${node.name || "Document"}\n\n${node.description || "Generated by ArchitectAI"}`
      case "json":
        return JSON.stringify({ description: node.description }, null, 2)
      case "css":
        return `/* ${node.description || "Styles"} */\n`
      default:
        return node.description || "// Generated file"
    }
  }

  private generateTypeScriptFile(node: any, path: string): string {
    const isComponent = path.includes("components") || path.includes("UI")
    const isApi = path.includes("api") || path.includes("routes")

    if (isComponent) {
      const name = node.name?.replace(/\.[^/.]+$/, "") || "Component"
      return `"use client"

import React from 'react'

/**
 * ${node.description || "UI Component"}
 */
export function ${name}() {
  return (
    <div className="${name.toLowerCase()}">
      {/* Component Content */}
    </div>
  )
}
`
    }

    if (isApi) {
      return `import { NextRequest, NextResponse } from 'next/server'

/**
 * ${node.description || "API Route"}
 */
export async function GET(request: NextRequest) {
  return NextResponse.json({ message: 'Success' })
}
`
    }

    return `/**\n * ${node.description || "Generated file"}\n */\n\nexport {};\n`
  }

  private generateAPIRoutes(zip: any, apis: any[]) {
    apis.forEach((api: any) => {
      const method = (api.method || "GET").toUpperCase()
      const path = (api.path || api.endpoint || "/api/route").replace(/^\//, "").replace(/\//g, "-")
      const routePath = `app/api/${path}/route.ts`

      const content = `import { NextRequest, NextResponse } from 'next/server'

/**
 * ${method} ${api.path || api.endpoint}
 * ${api.description || "API Route"}
 */
export async function ${method}(request: NextRequest) {
  ${api.auth_required ? `// AUTH REQUIRED\n` : ""}
  try {
    return NextResponse.json({ success: true, data: {} })
  } catch (error) {
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
  }
}
`
      zip.file(routePath, content)
    })
  }

  private generateDatabaseSchema(zip: any, schema: any) {
    if (schema.tables && Array.isArray(schema.tables)) {
      let prisma = `// Prisma schema generated by MetaSOP (SQLite for local usage)\n\ngenerator client {\n  provider = "prisma-client-js"\n}\n\ndatasource db {\n  provider = "sqlite"\n  url      = env("DATABASE_URL")\n}\n\n`

      schema.tables.forEach((table: any) => {
        const name = (table.table_name || table.name || "Model").toLowerCase()
        const ModelName = name.charAt(0).toUpperCase() + name.slice(1)

        prisma += `model ${ModelName} {\n`

        if (table.columns && Array.isArray(table.columns)) {
          table.columns.forEach((col: any, idx: number) => {
            const cName = col.name || `field${idx}`
            const cType = this.mapSqlToPrismaType(col.type || "string")
            const isPK = col.primary_key || idx === 0

            prisma += `  ${cName} ${cType}${isPK ? " @id @default(autoincrement())" : ""}\n`
          })
        }

        prisma += `  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\n`
      })

      zip.file("prisma/schema.prisma", prisma)
    }
  }

  private mapSqlToPrismaType(sql: string): string {
    const t = sql.toLowerCase()
    if (t.includes("int")) return "Int"
    if (t.includes("bool")) return "Boolean"
    if (t.includes("date") || t.includes("time")) return "DateTime"
    if (t.includes("float") || t.includes("double")) return "Float"
    return "String"
  }

  private generateComponents(zip: any, hierarchy: any) {
    const walk = (node: any, path: string = "components") => {
      const name = node.name || node.root || "UI"
      const fullPath = `${path}/${name}.tsx`

      const content = `"use client"\n\nimport React from 'react'\n\nexport function ${name}() {\n  return <div>{/* ${node.description || "Component"} */}</div>\n}\n`
      zip.file(fullPath, content)

      if (node.children && Array.isArray(node.children)) {
        node.children.forEach((c: any) => walk(c, `${path}/${name}`))
      }
    }
    walk(hierarchy)
  }

  private generateEnvTemplate(zip: any, envVars: any[]) {
    let content = "# Generated by MetaSOP\n\n"
    envVars.forEach((ev: any) => {
      content += `# ${ev.description || "Environment Variable"}\n${ev.name || "VAR"}=${ev.example || ""}\n\n`
    })
    zip.file(".env.example", content)
  }

  private generateDockerFiles(zip: any) {
    const dockerfile = `FROM node:20-alpine\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\nEXPOSE 3000\nCMD ["npm", "start"]`
    zip.file("Dockerfile", dockerfile)

    const compose = `version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - "3000:3000"\n    env_file:\n      - .env`
    zip.file("docker-compose.yml", compose)
  }
}
