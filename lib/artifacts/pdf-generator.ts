import type { Diagram } from "@/types/diagram"
import { DocumentationGenerator } from "./documentation-generator"

export class PDFGenerator {
  private diagram: Diagram
  private docGenerator: DocumentationGenerator

  constructor(diagram: Diagram) {
    this.diagram = diagram
    this.docGenerator = new DocumentationGenerator(diagram)
  }

  /**
   * Generate PDF documentation
   */
  async generatePDF(): Promise<Blob> {
    // Dynamically import jsPDF to avoid SSR issues
    const { jsPDF } = await import("jspdf")
    const doc = new jsPDF({
      orientation: "portrait",
      unit: "mm",
      format: "a4",
    })

    const pageWidth = doc.internal.pageSize.getWidth()
    const pageHeight = doc.internal.pageSize.getHeight()
    const margin = 20
    const maxWidth = pageWidth - 2 * margin
    let yPosition = margin

    // Helper to add new page if needed
    const checkNewPage = (requiredHeight: number) => {
      if (yPosition + requiredHeight > pageHeight - margin) {
        doc.addPage()
        yPosition = margin
        return true
      }
      return false
    }

    // Title
    doc.setFontSize(24)
    doc.setFont("helvetica", "bold")
    const titleLines = doc.splitTextToSize(this.diagram.title, maxWidth)
    doc.text(titleLines, margin, yPosition)
    yPosition += titleLines.length * 10 + 5

    // Date
    doc.setFontSize(10)
    doc.setFont("helvetica", "normal")
    doc.text(`Generated: ${new Date(this.diagram.createdAt).toLocaleString()}`, margin, yPosition)
    yPosition += 10

    // Description
    checkNewPage(20)
    doc.setFontSize(12)
    doc.setFont("helvetica", "bold")
    doc.text("Overview", margin, yPosition)
    yPosition += 8

    doc.setFontSize(10)
    doc.setFont("helvetica", "normal")
    const descLines = doc.splitTextToSize(this.diagram.description, maxWidth)
    doc.text(descLines, margin, yPosition)
    yPosition += descLines.length * 5 + 10

    // Generate markdown and convert to PDF sections
    const markdown = this.docGenerator.generateMarkdown()
    const sections = this.parseMarkdownToSections(markdown)

    sections.forEach((section) => {
      checkNewPage(15)

      // Section title
      if (section.level === 1) {
        doc.setFontSize(18)
        doc.setFont("helvetica", "bold")
        yPosition += 5
      } else if (section.level === 2) {
        doc.setFontSize(14)
        doc.setFont("helvetica", "bold")
        yPosition += 3
      } else {
        doc.setFontSize(12)
        doc.setFont("helvetica", "bold")
        yPosition += 2
      }

      const titleLines = doc.splitTextToSize(section.title, maxWidth)
      doc.text(titleLines, margin, yPosition)
      yPosition += titleLines.length * (section.level === 1 ? 8 : section.level === 2 ? 6 : 5) + 3

      // Section content
      if (section.content) {
        checkNewPage(20)
        doc.setFontSize(10)
        doc.setFont("helvetica", "normal")
        const contentLines = doc.splitTextToSize(section.content, maxWidth)
        contentLines.forEach((line: string) => {
          checkNewPage(5)
          doc.text(line, margin, yPosition)
          yPosition += 5
        })
        yPosition += 3
      }

      // Lists
      if (section.items && section.items.length > 0) {
        section.items.forEach((item: string) => {
          checkNewPage(5)
          doc.setFontSize(10)
          doc.setFont("helvetica", "normal")
          const itemLines = doc.splitTextToSize(`â€¢ ${item}`, maxWidth - 5)
          doc.text(itemLines, margin + 5, yPosition)
          yPosition += itemLines.length * 5
        })
        yPosition += 3
      }
    })

    // Footer on each page
    const totalPages = doc.getNumberOfPages()
    for (let i = 1; i <= totalPages; i++) {
      doc.setPage(i)
      doc.setFontSize(8)
      doc.setFont("helvetica", "italic")
      doc.text(
        `Page ${i} of ${totalPages} - Generated by ArchitectAI`,
        pageWidth / 2,
        pageHeight - 10,
        { align: "center" }
      )
    }

    return doc.output("blob")
  }

  private parseMarkdownToSections(markdown: string): Array<{
    level: number
    title: string
    content?: string
    items?: string[]
  }> {
    const lines = markdown.split("\n")
    const sections: Array<{
      level: number
      title: string
      content?: string
      items?: string[]
    }> = []

    let currentSection: any = null

    lines.forEach((line) => {
      // Headers
      if (line.startsWith("#")) {
        if (currentSection) {
          sections.push(currentSection)
        }
        const level = (line.match(/^#+/) || [""])[0].length
        const title = line.replace(/^#+\s*/, "").trim()
        currentSection = { level, title, items: [] }
      }
      // List items
      else if (line.trim().startsWith("-") || line.trim().startsWith("*")) {
        if (currentSection) {
          if (!currentSection.items) currentSection.items = []
          currentSection.items.push(line.replace(/^[-*]\s*/, "").trim())
        }
      }
      // Regular content
      else if (line.trim() && currentSection) {
        if (!currentSection.content) currentSection.content = ""
        currentSection.content += line.trim() + " "
      }
    })

    if (currentSection) {
      sections.push(currentSection)
    }

    return sections
  }
}

