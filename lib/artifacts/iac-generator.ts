import type { Diagram } from "@/types/diagram"

export class IaCGenerator {
  private diagram: Diagram
  private artifacts: any

  constructor(diagram: Diagram) {
    this.diagram = diagram
    this.artifacts = diagram.metadata?.metasop_artifacts || {}
  }

  /**
   * Generate Docker Compose file
   */
  generateDockerCompose(): string {
    const archContent = this.artifacts.arch_design?.content || {}
    const hasDatabase = !!archContent.database_schema

    let compose = `version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
    env_file:
      - .env
    depends_on:
${hasDatabase ? `      - db\n` : ""}    restart: unless-stopped
    networks:
      - app-network

`

    if (hasDatabase) {
      compose += `  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=${this.diagram.title.toLowerCase().replace(/\s+/g, "_")}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - app-network

`
    }

    compose += `networks:
  app-network:
    driver: bridge

`

    if (hasDatabase) {
      compose += `volumes:
  postgres-data:
`
    }

    return compose
  }

  /**
   * Generate Kubernetes manifests
   */
  generateKubernetesManifests(): { deployment: string; service: string; ingress?: string } {
    const appName = this.diagram.title.toLowerCase().replace(/\s+/g, "-")
    const archContent = this.artifacts.arch_design?.content || {}
    const hasDatabase = !!archContent.database_schema

    const deployment = `apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${appName}
  labels:
    app: ${appName}
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ${appName}
  template:
    metadata:
      labels:
        app: ${appName}
    spec:
      containers:
      - name: ${appName}
        image: ${appName}:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: PORT
          value: "3000"
        ${hasDatabase ? `- name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: ${appName}-secrets
              key: database-url` : ""}
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
`

    const service = `apiVersion: v1
kind: Service
metadata:
  name: ${appName}-service
spec:
  selector:
    app: ${appName}
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer
`

    const ingress = `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ${appName}-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - ${appName}.example.com
    secretName: ${appName}-tls
  rules:
  - host: ${appName}.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: ${appName}-service
            port:
              number: 80
`

    return {
      deployment,
      service,
      ingress,
    }
  }

  /**
   * Generate Terraform configuration
   */
  generateTerraform(): string {
    const appName = this.diagram.title.toLowerCase().replace(/\s+/g, "-")
    const archContent = this.artifacts.arch_design?.content || {}
    const hasDatabase = !!archContent.database_schema

    return `# Terraform configuration generated by ArchitectAI
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

# VPC
resource "aws_vpc" "main" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "${appName}-vpc"
  }
}

# Internet Gateway
resource "aws_internet_gateway" "main" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = "${appName}-igw"
  }
}

# Public Subnet
resource "aws_subnet" "public" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "us-east-1a"
  map_public_ip_on_launch = true

  tags = {
    Name = "${appName}-public-subnet"
  }
}

# Route Table
resource "aws_route_table" "public" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.main.id
  }

  tags = {
    Name = "${appName}-public-rt"
  }
}

resource "aws_route_table_association" "public" {
  subnet_id      = aws_subnet.public.id
  route_table_id = aws_route_table.public.id
}

# Security Group
resource "aws_security_group" "app" {
  name        = "${appName}-sg"
  description = "Security group for ${appName}"
  vpc_id      = aws_vpc.main.id

  ingress {
    description = "HTTP"
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    description = "HTTPS"
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "${appName}-sg"
  }
}

# EC2 Instance
resource "aws_instance" "app" {
  ami           = "ami-0c55b159cbfafe1f0" # Amazon Linux 2023
  instance_type = "t3.medium"
  subnet_id     = aws_subnet.public.id
  security_groups = [aws_security_group.app.id]

  user_data = <<-EOF
              #!/bin/bash
              yum update -y
              yum install -y docker
              systemctl start docker
              systemctl enable docker
              usermod -a -G docker ec2-user
              # Add your deployment commands here
              EOF

  tags = {
    Name = "${appName}-instance"
  }
}

${hasDatabase ? this.generateTerraformDatabase(appName) : ""}

# Outputs
output "instance_ip" {
  value = aws_instance.app.public_ip
}

output "vpc_id" {
  value = aws_vpc.main.id
}
`
  }

  private generateTerraformDatabase(appName: string): string {
    return `
# RDS Database
resource "aws_db_subnet_group" "main" {
  name       = "${appName}-db-subnet-group"
  subnet_ids = [aws_subnet.public.id]

  tags = {
    Name = "${appName}-db-subnet-group"
  }
}

resource "aws_db_instance" "main" {
  identifier             = "${appName}-db"
  engine                 = "postgres"
  engine_version         = "15.4"
  instance_class         = "db.t3.micro"
  allocated_storage      = 20
  storage_type           = "gp3"
  db_name                = "${appName.replace(/-/g, "_")}"
  username               = "postgres"
  password               = "changeme" # Use AWS Secrets Manager in production
  vpc_security_group_ids = [aws_security_group.app.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  skip_final_snapshot    = true

  tags = {
    Name = "${appName}-database"
  }
}
`
  }
}

