import JSZip from "jszip";
import { EngineerBackendArtifact } from "../artifacts/engineer/types";

/**
 * Utility to generate a project scaffold ZIP from agent artifacts
 */
export class ProjectScaffolder {
    /**
     * Generates a project ZIP based on the Engineer artifact
     */
    static async generateProjectZip(engineerArtifact: EngineerBackendArtifact): Promise<Blob> {
        const zip = new JSZip();
        const rootDir = engineerArtifact.artifact_path || "project-scaffold";
        const folder = zip.folder(rootDir);

        if (!folder) {
            throw new Error("Failed to create root directory in ZIP");
        }

        // 1. Build File Structure
        if (engineerArtifact.file_structure) {
            this.addFileStructure(folder, engineerArtifact.file_structure);
        }

        // 2. Generate package.json
        const packageJson = this.generatePackageJson(engineerArtifact);
        folder.file("package.json", JSON.stringify(packageJson, null, 2));

        // 3. Generate README.md
        const readme = this.generateReadme(engineerArtifact);
        folder.file("README.md", readme);

        // 4. Generate .env.example
        const envExample = this.generateEnvExample(engineerArtifact);
        if (envExample) {
            folder.file(".env.example", envExample);
        }

        // Generate the ZIP blob
        return await zip.generateAsync({ type: "blob" });
    }

    /**
     * Recursively adds file structure to the ZIP folder
     */
    private static addFileStructure(folder: JSZip, node: any) {
        if (node.type === "directory") {
            const subFolder = folder.folder(node.name);
            if (subFolder && node.children) {
                node.children.forEach((child: any) => {
                    this.addFileStructure(subFolder, child);
                });
            }
        } else if (node.type === "file") {
            // Create a skeleton file with a description as a comment
            const extension = node.name.split(".").pop();
            let content = "";

            if (["ts", "tsx", "js", "jsx"].includes(extension)) {
                content = `/**\n * ${node.description || node.name}\n */\n\nexport {};\n`;
            } else if (["md"].includes(extension)) {
                content = `# ${node.name}\n\n${node.description || "Generated file"}\n`;
            } else if (["css"].includes(extension)) {
                content = `/* ${node.description || node.name} */\n`;
            } else {
                content = `${node.description || "Generated file"}\n`;
            }

            folder.file(node.name, content);
        }
    }

    /**
     * Generates package.json content
     */
    private static generatePackageJson(artifact: EngineerBackendArtifact) {
        const dependencies: Record<string, string> = {};
        const devDependencies: Record<string, string> = {
            "typescript": "^5.0.0",
            "@types/node": "^20.0.0",
        };

        if (artifact.dependencies) {
            artifact.dependencies.forEach((dep: string) => {
                const [name, version] = dep.split("@");
                dependencies[name] = version || "latest";
            });
        }

        return {
            name: artifact.artifact_path || "project-scaffold",
            version: "0.1.0",
            description: "Scaffolded by MetaSOP",
            scripts: {
                "dev": artifact.run_results?.dev_commands?.[0] || "next dev",
                "build": "next build",
                "start": "next start",
                "test": artifact.run_results?.test_commands?.[0] || "vitest",
                "setup": artifact.run_results?.setup_commands?.join(" && ") || "npm install",
            },
            dependencies,
            devDependencies,
        };
    }

    /**
     * Generates README.md content
     */
    private static generateReadme(artifact: EngineerBackendArtifact): string {
        return `# ${artifact.artifact_path?.toUpperCase() || "Project Scaffold"}

Generated by MetaSOP Multi-Agent Platform.

## ðŸš€ Setup & Execution

### Installation
\`\`\`bash
${artifact.run_results?.setup_commands?.join("\n") || "npm install"}
\`\`\`

### Run Options
- **Development**: \`${artifact.run_results?.dev_commands?.join(" / ") || "npm run dev"}\`
- **Testing**: \`${artifact.run_results?.test_commands?.join(" / ") || "npm test"}\`

## ðŸ“– Implementation Roadmap

${artifact.implementation_plan_phases && artifact.implementation_plan_phases.length > 0
            ? artifact.implementation_plan_phases
                .map((phase: any, index: number) => `### Phase ${index + 1}: ${phase.name}\n${phase.description || ""}\n${Array.isArray(phase.tasks) && phase.tasks.length > 0 ? phase.tasks.map((task: string) => `- ${task}`).join("\n") : ""}`)
                .join("\n\n")
            : "No implementation roadmap provided."}

## âš™ï¸ Technical Decisions

${artifact.technical_decisions
                ? artifact.technical_decisions.map((d: any) => `### ${d.decision}\n**Rationale**: ${d.rationale}\n${d.alternatives ? `**Alternatives**: ${d.alternatives}` : ""}`).join("\n\n")
                : "No specific technical decisions logged."}
`;
    }

    /**
     * Generates .env.example content
     */
    private static generateEnvExample(artifact: EngineerBackendArtifact): string | null {
        if (!artifact.environment_variables || artifact.environment_variables.length === 0) {
            return null;
        }

        return artifact.environment_variables
            .map((env: any) => `# ${env.description}\n${env.name}=${env.example || ""}`)
            .join("\n\n");
    }
}
